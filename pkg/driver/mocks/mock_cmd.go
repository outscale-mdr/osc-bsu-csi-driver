// Code generated by MockGen. DO NOT EDIT.
// Source: /home/outscale/go/pkg/mod/k8s.io/utils@v0.0.0-20220210201930-3a6ce19ff2f9/exec/exec.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	io "io"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	exec "k8s.io/utils/exec"
)

// MockInterface is a mock of Interface interface.
type MockInterface struct {
	ctrl     *gomock.Controller
	recorder *MockInterfaceMockRecorder
}

// MockInterfaceMockRecorder is the mock recorder for MockInterface.
type MockInterfaceMockRecorder struct {
	mock *MockInterface
}

// NewMockInterface creates a new mock instance.
func NewMockInterface(ctrl *gomock.Controller) *MockInterface {
	mock := &MockInterface{ctrl: ctrl}
	mock.recorder = &MockInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInterface) EXPECT() *MockInterfaceMockRecorder {
	return m.recorder
}

// Command mocks base method.
func (m *MockInterface) Command(cmd string, args ...string) exec.Cmd {
	m.ctrl.T.Helper()
	varargs := []interface{}{cmd}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Command", varargs...)
	ret0, _ := ret[0].(exec.Cmd)
	return ret0
}

// Command indicates an expected call of Command.
func (mr *MockInterfaceMockRecorder) Command(cmd interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{cmd}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Command", reflect.TypeOf((*MockInterface)(nil).Command), varargs...)
}

// CommandContext mocks base method.
func (m *MockInterface) CommandContext(ctx context.Context, cmd string, args ...string) exec.Cmd {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, cmd}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CommandContext", varargs...)
	ret0, _ := ret[0].(exec.Cmd)
	return ret0
}

// CommandContext indicates an expected call of CommandContext.
func (mr *MockInterfaceMockRecorder) CommandContext(ctx, cmd interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, cmd}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommandContext", reflect.TypeOf((*MockInterface)(nil).CommandContext), varargs...)
}

// LookPath mocks base method.
func (m *MockInterface) LookPath(file string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LookPath", file)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LookPath indicates an expected call of LookPath.
func (mr *MockInterfaceMockRecorder) LookPath(file interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LookPath", reflect.TypeOf((*MockInterface)(nil).LookPath), file)
}

// MockCmd is a mock of Cmd interface.
type MockCmd struct {
	ctrl     *gomock.Controller
	recorder *MockCmdMockRecorder
}

// MockCmdMockRecorder is the mock recorder for MockCmd.
type MockCmdMockRecorder struct {
	mock *MockCmd
}

// NewMockCmd creates a new mock instance.
func NewMockCmd(ctrl *gomock.Controller) *MockCmd {
	mock := &MockCmd{ctrl: ctrl}
	mock.recorder = &MockCmdMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCmd) EXPECT() *MockCmdMockRecorder {
	return m.recorder
}

// CombinedOutput mocks base method.
func (m *MockCmd) CombinedOutput() ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CombinedOutput")
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CombinedOutput indicates an expected call of CombinedOutput.
func (mr *MockCmdMockRecorder) CombinedOutput() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CombinedOutput", reflect.TypeOf((*MockCmd)(nil).CombinedOutput))
}

// Output mocks base method.
func (m *MockCmd) Output() ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Output")
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Output indicates an expected call of Output.
func (mr *MockCmdMockRecorder) Output() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockCmd)(nil).Output))
}

// Run mocks base method.
func (m *MockCmd) Run() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run")
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockCmdMockRecorder) Run() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockCmd)(nil).Run))
}

// SetDir mocks base method.
func (m *MockCmd) SetDir(dir string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetDir", dir)
}

// SetDir indicates an expected call of SetDir.
func (mr *MockCmdMockRecorder) SetDir(dir interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDir", reflect.TypeOf((*MockCmd)(nil).SetDir), dir)
}

// SetEnv mocks base method.
func (m *MockCmd) SetEnv(env []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetEnv", env)
}

// SetEnv indicates an expected call of SetEnv.
func (mr *MockCmdMockRecorder) SetEnv(env interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetEnv", reflect.TypeOf((*MockCmd)(nil).SetEnv), env)
}

// SetStderr mocks base method.
func (m *MockCmd) SetStderr(out io.Writer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStderr", out)
}

// SetStderr indicates an expected call of SetStderr.
func (mr *MockCmdMockRecorder) SetStderr(out interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStderr", reflect.TypeOf((*MockCmd)(nil).SetStderr), out)
}

// SetStdin mocks base method.
func (m *MockCmd) SetStdin(in io.Reader) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStdin", in)
}

// SetStdin indicates an expected call of SetStdin.
func (mr *MockCmdMockRecorder) SetStdin(in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStdin", reflect.TypeOf((*MockCmd)(nil).SetStdin), in)
}

// SetStdout mocks base method.
func (m *MockCmd) SetStdout(out io.Writer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStdout", out)
}

// SetStdout indicates an expected call of SetStdout.
func (mr *MockCmdMockRecorder) SetStdout(out interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStdout", reflect.TypeOf((*MockCmd)(nil).SetStdout), out)
}

// Start mocks base method.
func (m *MockCmd) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockCmdMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockCmd)(nil).Start))
}

// StderrPipe mocks base method.
func (m *MockCmd) StderrPipe() (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StderrPipe")
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StderrPipe indicates an expected call of StderrPipe.
func (mr *MockCmdMockRecorder) StderrPipe() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StderrPipe", reflect.TypeOf((*MockCmd)(nil).StderrPipe))
}

// StdoutPipe mocks base method.
func (m *MockCmd) StdoutPipe() (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StdoutPipe")
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StdoutPipe indicates an expected call of StdoutPipe.
func (mr *MockCmdMockRecorder) StdoutPipe() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StdoutPipe", reflect.TypeOf((*MockCmd)(nil).StdoutPipe))
}

// Stop mocks base method.
func (m *MockCmd) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockCmdMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockCmd)(nil).Stop))
}

// Wait mocks base method.
func (m *MockCmd) Wait() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Wait")
	ret0, _ := ret[0].(error)
	return ret0
}

// Wait indicates an expected call of Wait.
func (mr *MockCmdMockRecorder) Wait() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Wait", reflect.TypeOf((*MockCmd)(nil).Wait))
}

// MockExitError is a mock of ExitError interface.
type MockExitError struct {
	ctrl     *gomock.Controller
	recorder *MockExitErrorMockRecorder
}

// MockExitErrorMockRecorder is the mock recorder for MockExitError.
type MockExitErrorMockRecorder struct {
	mock *MockExitError
}

// NewMockExitError creates a new mock instance.
func NewMockExitError(ctrl *gomock.Controller) *MockExitError {
	mock := &MockExitError{ctrl: ctrl}
	mock.recorder = &MockExitErrorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExitError) EXPECT() *MockExitErrorMockRecorder {
	return m.recorder
}

// Error mocks base method.
func (m *MockExitError) Error() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Error")
	ret0, _ := ret[0].(string)
	return ret0
}

// Error indicates an expected call of Error.
func (mr *MockExitErrorMockRecorder) Error() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockExitError)(nil).Error))
}

// ExitStatus mocks base method.
func (m *MockExitError) ExitStatus() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExitStatus")
	ret0, _ := ret[0].(int)
	return ret0
}

// ExitStatus indicates an expected call of ExitStatus.
func (mr *MockExitErrorMockRecorder) ExitStatus() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExitStatus", reflect.TypeOf((*MockExitError)(nil).ExitStatus))
}

// Exited mocks base method.
func (m *MockExitError) Exited() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exited")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exited indicates an expected call of Exited.
func (mr *MockExitErrorMockRecorder) Exited() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exited", reflect.TypeOf((*MockExitError)(nil).Exited))
}

// String mocks base method.
func (m *MockExitError) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockExitErrorMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockExitError)(nil).String))
}
